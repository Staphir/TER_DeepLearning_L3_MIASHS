
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Notre programme &#8212; Documentation TER_DeepLearning </title>
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/my-styles.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="_static/additional_javascript.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>




  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
           </a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="index.html">Accueil</a></li>
                <li><a href="historique.html">Etat de l'art</a></li>
                <li><a href="definitions.html">Définitions</a></li>
                <li><a href="biblioteques.html">Bibliotèques python</a></li>
                <li><a href="#">Notre programme</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          <!---->
            <!--
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>-->
          <!---->
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Introduction</a></li>
<li><a class="reference internal" href="#la-methode-dimplementation">La méthode d’implémentation</a></li>
<li><a class="reference internal" href="#le-shift-it">Le Shift It</a><ul>
<li><a class="reference internal" href="#exemple-du-shift-it-sur-android">Exemple du Shift It sur Android</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lentrainement-de-lia">L’entraînement de l’IA</a><ul>
<li><a class="reference internal" href="#la-creation-des-donnees-dentrainement">La création des données d’entraînement :</a></li>
<li><a class="reference internal" href="#le-modele-dentrainement">Le modèle d’entraînement</a></li>
</ul>
</li>
</ul>

<form action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Lien permanent vers ce titre">¶</a></h1>
<hr class="docutils" />
<div class="toctree-wrapper compound">
</div>
<p>Notre but aura été de trouver les différentes méthodes de résolution de casse-têtes par algorithmes de deep-learning,
c’est à dire créer un outil utilisant le deep-learning et l’entraîner sur des données
correspondant à des situations que l’on peut rencontrer dans un casse-tête.</p>
<p>Il est avant tout important de noter que ce travail est un sujet de recherche.
Quand nous avons commencé la réalisation de ce projet, nous n’avions aucune idée de où cela allait nous mener.</p>
<p>Nos bases concernant ces système d’apprentissage étant quasi-inexistantes au commencement de ce projet,
il a été nécessaire de tenter de comprendre les différents modules mis à notre disposition
en réalisant des tutoriels de manipulation proposés par les équipes de développement ou
encore d’autres personnes proposant une explication guidée de l’utilisation de telle ou telle bibliothèque.
Vous pourrez retrouver tous les liens dans la <a class="reference external" href="bibliographie.html">bibliographie</a>.
Il est aussi important de noter que certains modules complémentaires sont devenus indispensable
lors de l’utilisation de ces bibliothèques de Réseaux de Neurones et ont donc nécessité que l’on s’y intéresse
et apprenne à les manipuler (Matplotlib et NumPy notamment).</p>
</div>
<hr class="docutils" />
<div class="section" id="la-methode-dimplementation">
<h1>La méthode d’implémentation<a class="headerlink" href="#la-methode-dimplementation" title="Lien permanent vers ce titre">¶</a></h1>
<hr class="docutils" />
<div class="toctree-wrapper compound">
</div>
<p>Pour créer notre propre algorithme de Deep-Learning nous avons commencé par choisir
la méthode suivant laquelle nous allions fournir nos données à l’algorithme.
Comme mentionné dans <a class="reference external" href="historique.html">l’état de l’art</a> cette étape dans la création d’une méthode d’apprentissage par Deep-Learning est très importante.
Pour ce faire, nous nous sommes basé sur l’implémentation de Jeremy Pinto (<a class="reference external" href="https://github.com/jerpint/rubiks_cube_convnet">github de son projet</a>)
pour concevoir notre générateur de données.</p>
<p>Son implémentation consiste en générer des partie aléatoires de Rubik’s cube en partant d’un état résolu
puis mélangé un certain nombre de fois (10 dans son cas). Après quoi il utilise le chemin vers l’état mélangé <em>Scrambled state</em>
pour trouver le chemin inverse vers la résolution.</p>
<p>En partant de l’état mélangé et en appliquant le premier mouvement du chemin vers la résolution,
il obtient l’état suivant de la matrice vers résolution, puis construit des pairs
(matrice (6x3x3 - 6 faces de 3 cellules en hauteur et 3 cellules en largeur) - mouvement),
la matrice correspondant à l’état mélangé du cube et le mouvement à celui qu’il faut effectuer pour atteindre un état de résolution plus proche du cube résolu.</p>
<p>Pour plus de clarté, voici le pseudo code du déroulement de la génération des données :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="c1"># Nombre d&#39;itération souhaitée</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># stockage des matrices</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># stockage des mouvements</span>

<span class="n">pour</span> <span class="n">i</span> <span class="n">de</span> <span class="mi">1</span> <span class="n">à</span> <span class="n">N</span> <span class="p">:</span>

    <span class="n">cube</span> <span class="o">=</span> <span class="n">mycube</span><span class="p">()</span> <span class="c1"># générer un nouvel objet cube avec 6 faces de 3x3 cellules</span>

    <span class="c1"># mélanger l&#39;état du cube 10 fois et récupérer le chemin de mélange</span>
    <span class="n">chemin_vers_état_mélangé</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">mélanger</span><span class="p">(</span> <span class="mi">10</span> <span class="p">)</span> 
    
    <span class="c1"># obtenir le chemin à effectuer depuis l&#39;état mélangé</span>
    <span class="n">chemin_vers_resolution</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">inverser_chemin</span><span class="p">(</span> <span class="n">chemin_vers_état_mélangé</span> <span class="p">)</span>

    <span class="n">pour</span> <span class="n">chaque</span> <span class="n">mouvement</span> <span class="n">dans</span> <span class="n">chemin_vers_resolution</span> <span class="p">:</span>

        <span class="c1"># récupérer l&#39;état actuel de la matrice du cube</span>
        <span class="n">grille</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">grille</span><span class="p">()</span>

        <span class="c1"># stocker les données dans 2 listes différentes </span>
        <span class="c1"># où ces données se situront au même indice</span>
        <span class="n">X</span><span class="o">.</span><span class="n">ajouter</span><span class="p">(</span> <span class="n">grille</span> <span class="p">)</span>
        <span class="n">y</span><span class="o">.</span><span class="n">ajouter</span><span class="p">(</span> <span class="n">mouvement</span> <span class="p">)</span>
        
        <span class="c1"># générer l&#39;état suivant du cube</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">appliquer_mouvement</span><span class="p">(</span> <span class="n">mouvement</span> <span class="p">)</span>

<span class="n">fin</span> <span class="n">pour</span> 
</pre></div>
</div>
<p>Le but de son algorithme est de pouvoir entraîner la machine à, pour une certaine configuration du cube,
prédire le mouvement à effectuer pour se rapprocher de l’état résolu.
Il effectue donc ici un apprentissage supervisé en fournissant à chaque fois un état du cube
et son mouvement associé puis en demandant à son réseau de neurone de prédire le prochain mouvement à faire.
La rétropropagation se fait alors sur la comparaison entre le mouvement prédit et celui fourni.</p>
<p>Après 12h d’entraînement de son réseau de neurone, il parvient à obtenir un modèle capable de résoudre
avec un bon taux de réussite un Rubik’s cube mélangé 6 fois (6 pas de différence avec l’état résolu).
Le modèle n’est pas parfait et au delà de 6 mouvements aléatoires,
le NN ne parvient plus vraiment à trouver les solutions comme on peut le voir ci dessous.</p>
<a class="reference internal image-reference" href="_images/cube_solving.gif"><img alt="_images/cube_solving.gif" class="align-center" src="_images/cube_solving.gif" style="width: 426.40000000000003px; height: 366.6px;" /></a>
<p>Etant donné cette implémentation est globalement la seule et unique
que nous avons pu relever au travers de nos recherches,
le choix de la méthode de construction de notre propre réseau de neurone
n’en a finalement pas été réellement un.</p>
<p>Nous avons donc commencé par construire notre propre jeu,
puzzle numérique sur lequel entraîner notre réseau de neurones
tout en prenant compte du fait qu’il allait devoir communiquer
d’une certaine manièreavec d’autre programmes de Machine Learning.</p>
<p>Le jeu que nous avons décidé de reproduire se nomme le Shift It.
C’est un jeu qui fut développé à l’origine sous Android mais qui à l’instant n’est plus disponible
sur les plateformes de téléchargement principales (Google Play Store) bien qu’il soit toujours possible
de le récupérer sous forme de fichier .apk sur certains hébergeurs.</p>
</div>
<hr class="docutils" />
<div class="section" id="le-shift-it">
<h1>Le Shift It<a class="headerlink" href="#le-shift-it" title="Lien permanent vers ce titre">¶</a></h1>
<hr class="docutils" />
<div class="toctree-wrapper compound">
</div>
<p>Le Shift It se joue avec une grille comportant des carrés de plusieurs couleurs.
Le but est d’avoir une grille où toutes les cases de la même couleur formes une seul zone.
Il faut donc autant de zones que de couleurs et que chaque case soit adjacente avec au moins une autre case de la même couleur.</p>
<p>Voici un visuel du jeu :</p>
<div class="section" id="exemple-du-shift-it-sur-android">
<h2>Exemple du Shift It sur Android<a class="headerlink" href="#exemple-du-shift-it-sur-android" title="Lien permanent vers ce titre">¶</a></h2>
<p>Notre version du Shift It est composé d’une grille de taille et de nombre de couleurs modifiables
(pour l’instant le nombre de couleurs à été bloqué à 2). Pour l’apprentissage de notre modèle,
nous nous sommes fixé une taille de 5x5 et uniquement 2 couleurs différents.
Des configurations plus compliqués d’entraînement seront envisageables dans le futur.</p>
<p>Nous avons commencé par créer une classe Python, correspondant à la partie fonctionnelle du jeu,
doté d’attributs permettants de stocker la hauteur et la largeur de la grille en plus de la grille elle-même
ainsi que le chemin de mouvements nécessaire à effectuer depuis l’état actuel pour obtenir l’état de résolution.
Elle conserve aussi une sauvegarde de son état résolu ainsi qu’un solveur qui utilise le modèle généré grâce au Deep Learning.</p>
<p>Les principales fonctionnalités du programme sont les suivantes :</p>
<ul class="simple">
<li>generate() : permet de générer aléatoirement une grille de jeu résolue.</li>
<li>shuffle(n) : permet de sélectionner aléatoirement des mouvements et les appliquer,
le paramètre n correspond au nombre de mouvements aléatoire appliqués.
Cette méthode renvoie le chemin inverse de celui qui a été fait en mélangeant.</li>
<li>shift(key) : permet d’effectuer le mouvement de la ligne ou de la colonne déterminé par la valeur key.</li>
<li>solve_with_IA(limit) : permet de faire fonctionner le réseau de neurone sur l’état actuel de la grille
pour prédire le mouvement à faire. Le paramètre limit correspond au nombre maximum de mouvement
que doit prédire le réseau (s’avère plutôt utile lorsque le modèle ne parvient pas à atteindre
la résolution - ce qui arrive 99% du temps)</li>
<li>reset() : permet de remettre la grille à son état résolu mais sans générer une nouvelle configuration.</li>
</ul>
<p>Ainsi que les principales propriétés :</p>
<ul class="simple">
<li>width : largeur</li>
<li>height : hauteur</li>
<li>state: booléen indiquant si le jeu est résolu ou non</li>
<li>moves : la liste des mouvements possibles en fonction de la grille</li>
</ul>
<p>Les mouvements possibles sont représentés par des chaînes de caractères de longueur 2 ou 1.
Elles sont composées d’un entier désignant la ligne ou la colonne à faire défiler ainsi
que du caractère «&nbsp;‘&nbsp;» (apostrophe) désignant le sens de défilement.
Si le défilement est dans le sens normal (haut en bas pour la colonne et de gauche à droite pour la ligne)
alors la chaîne de caractères est uniquement composée du numéro de la ligne ou colonne.
Ce numéro désignant la ligne ou la colonne est un entier pair si l’élément sélectionné est une ligne et,
à l’inverse, est impair si c’est une colonne. La première ligne de la grille sera numéroté 0,
la deuxième ligne sera numéroté 2 et la troisième colonne sera numéroté 5 par exemple.
Ainsi le mouvement désigné par 9’ correspondra à un défilement de bas en haut de la dernière colonne de la grille.
Alors sur une grille de NxM, il y aura (N+M)x2 mouvements possibles soit 20 dans une configuration de 5 par 5.</p>
<p>Notre code est accessible au lien suivant : <a class="reference external" href="https://github.com/Staphir/TER_DeepLearning_L3_MIASHS">GitHub</a></p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="lentrainement-de-lia">
<h1>L’entraînement de l’IA<a class="headerlink" href="#lentrainement-de-lia" title="Lien permanent vers ce titre">¶</a></h1>
<hr class="docutils" />
<div class="toctree-wrapper compound">
</div>
<p>Afin d’entraîner notre programme d’intelligence artificielle, nous avions besoin de deux choses.
D’une part des données d’entrainements qui seront construites en utilisant l’implémentation de
notre Shift it et d’autre part du modèle dans lequel nous feront passer ces données.</p>
<div class="section" id="la-creation-des-donnees-dentrainement">
<h2>La création des données d’entraînement :<a class="headerlink" href="#la-creation-des-donnees-dentrainement" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour construire un set de données utilisables par un modèle d’apprentissage,
nous nous sommes inspirés de la méthode de Jeremy Pinto et avons généré de la même manière
que lui des pairs grilles / mouvement, les grilles correspondant aux features et les mouvements aux labels.
Il est possible de passer directement le mouvement sous forme de chaîne de caractère
au système d’apprentissage mais dans notre cas nous avons simplifié cette information
en associant un indice à chaque mouvement. Ces sont ces indices qui sont fournis au système.</p>
<p>Premièrement, nous avons construit la méthode de génération de parties :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_game</span><span class="p">()</span> <span class="p">:</span>

    <span class="k">if</span> <span class="n">_use_random_playground</span> <span class="p">:</span>
        <span class="c1"># generate random playground</span>
        <span class="n">mygame</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="c1"># or reset to learn on exact same starting pattern</span>
        <span class="c1"># would be nice to try out if no result with random patterns</span>
        <span class="n">mygame</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="c1"># shuffle playground and get path to success</span>
    <span class="n">path_to_success</span> <span class="o">=</span> <span class="n">mygame</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">max_moves</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mygame</span><span class="p">),</span> <span class="n">path_to_success</span>
</pre></div>
</div>
<p>Cette méthode permet de créer un objet jeu (une instance de notre ShiftIt)
dans un état mélangé ainsi que le chemin vers succès associé (une liste de mouvements).
Ce couple d’élément est alors renvoyé par la méthode une fois qu’il est créé.</p>
<p>La méthode suivante consiste en, pour un couple d’éléments comme cités juste avant,
générer toutes les paires grille / mouvement comme expliqué plus tôt (algorithme en pseudocode).
De cette manière, si l’on mélange chacun des jeux en 10 coups, ils se verront tous associé
une liste de 10 pairs grille / mouvement correspondant aux états intermédiaires avec
les mouvements à effectuer pour passer à celui suivant.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_game_data</span><span class="p">(</span><span class="n">game</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="p">:</span>
    <span class="c1"># grid x next_step_to_solution</span>
    <span class="n">_solList</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># iterate over the path</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">path</span> <span class="p">:</span>

        <span class="c1"># get the playground as numpy.array before applying key</span>
        <span class="n">_grid</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">list_grid</span>

        <span class="c1"># get the integer associated to the key</span>
        <span class="n">_label</span> <span class="o">=</span> <span class="n">reverse_moves</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># store grid and integer</span>
        <span class="n">_solList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="n">_grid</span><span class="p">,</span> <span class="n">_label</span> <span class="p">])</span>

        <span class="c1"># execute key</span>
        <span class="n">game</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1"># send back each resolution step</span>
    <span class="k">return</span> <span class="n">_solList</span>
</pre></div>
</div>
<p>Pour finir, la dernière méthode a été implémentée sous la forme d’un générateur Python
(<a class="reference external" href="https://wiki.python.org/moin/Generators">voir la documentation</a>) et permet de renvoyer,
un nombre de fois définit par la variable <em>game_count</em>,
le traitement des éléments renvoyés par la première méthode au travers de la seconde.
Ainsi, nous créons un plus gros ensemble de pairs grille / mouvement
qui sont alors fournis séparément au modèle, avec d’un côté les grilles à partir desquelles
extraire les informations et prédire les mouvements et de l’autre, les mouvements correctes
vers lesquels les prédictions doivent tendre (utilisés pour la rétropropagation).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">data_generator</span><span class="p">(</span><span class="n">game_count</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="p">:</span> <span class="c1"># iterator</span>
    <span class="c1"># set iteration number</span>
    <span class="n">_iter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">_iter</span> <span class="o">&lt;</span> <span class="n">game_count</span> <span class="p">:</span>

        <span class="c1"># get ready for use game object and path</span>
        <span class="n">game</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">generate_game</span><span class="p">()</span>
        
        <span class="c1"># yield solution list for each game</span>

        <span class="k">yield</span> <span class="n">generate_game_data</span><span class="p">(</span><span class="n">game</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

        <span class="n">_iter</span> <span class="o">+=</span><span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="le-modele-dentrainement">
<h2>Le modèle d’entraînement<a class="headerlink" href="#le-modele-dentrainement" title="Lien permanent vers ce titre">¶</a></h2>
<p>Ici, le modèle d’entraînement fait référence à l’ensemble des couches utilisées
pour construire le réseau de neurone au complet, donc à l’<em>input layer</em>, l’<em>output layer</em>,
ainsi que les <em>hidden layers</em> qui viennent entre les deux.
Il est en généralement requis de dédier un temps relativement conséquent à son optimisation,
c’est à dire à savoir exactement quels types de layers implémenter et dans quel ordre.</p>
<p>Malheureusement, nous n’avons pas eu les connaissances nécessaires afin de pouvoir
mener cette étape à bien et de ce fait avons dû utiliser (et modifier) les modèles proposés par Jeremy Pinto
ainsi que d’autres que l’on a pu rencontrer au travers de différents tutoriels trouvés sur le net.
Il est d’ailleurs fort probable que ce fut la raison pour laquelle notre modèle
n’était pas en mesure de résoudre correctement même la plus simple des configuration que nous lui fournissions…</p>
<p>Ci-dessous le modèle que nous avons utilisé :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>

<span class="c1"># --- input ---</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">input_shape</span><span class="o">=</span><span class="n">input_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="c1"># model.add(MaxPooling2D(pool_size=(2,2), dim_ordering=&quot;th&quot;))</span>

<span class="c1"># --- hidden layers ---</span>
<span class="c1"># model.add(Conv2D(64, (3,3), input_shape=input_shape[1:], activation=&#39;relu&#39;))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="c1"># model.add(MaxPooling2D(pool_size=(2,2), dim_ordering=&quot;th&quot;))</span>

<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>
<span class="c1"># model.add(Conv2D(64, kernel_size=(3,3), activation=&#39;relu&#39;))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;tanh&#39;</span><span class="p">))</span>

<span class="c1"># --- output ---</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">outputl</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/casse_tete.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2019, Tim Laurençon, Martin Devreese et Maxime Dulieu.<br/>
      Créé avec <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>